#ifndef __LBFGSB_PROTOTYPES_H__
#define __LBFGSB_PROTOTYPES_H__

#ifdef __cplusplus
extern "C" {
#endif

/*     This subroutine partitions the working arrays wa and iwa, and 
 *       then uses the limited memory BFGS method to solve the bound
 *       constrained optimization problem by calling mainlb.
 *       (The direct method will be used in the subspace minimization.)
 *
 *     n is an integer, the dimension of the problem.
 *
 *     m is an integer, the maximum number of variable metric corrections
 *         used to define the limited memory matrix.
 *
 *     x is a double array of dimension n.
 *       \in x is an approximation to the solution.
 *       \out x is the current approximation.
 *
 *     l is a double array of dimension n, the lower bound on x.
 *
 *     u is a double array of dimension n, the upper bound on x.
 *
 *     nbd is an integer array of dimension n. nbd represents the type of bounds
 *     imposed on the variables, and must be specified as follows:
 *         nbd(i)=0 if x(i) is unbounded,
 *                1 if x(i) has only a lower bound,
 *                2 if x(i) has both lower and upper bounds, and
 *                3 if x(i) has only an upper bound.
 *
 *     f is a double.
 *       On first entry f is unspecified.
 *       On final exit f is the value of the function at x.
 *
 *     g is a double array of dimension n.
 *       On first entry g is unspecified.
 *       On final exit g is the value of the gradient at x.
 *
 *     factr is a double.
 *       On entry factr >= 0 is specified by the user.  The iteration
 *         will stop when
 *
 *         (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
 *
 *         where epsmch is the machine precision, which is automatically
 *         generated by the code. Typical values for factr: 1.d+12 for
 *         low accuracy; 1.d+7 for moderate accuracy; 1.d+1 for extremely
 *         high accuracy.
 *       On exit factr is unchanged.
 *
 *     pgtol is a double.
 *       On entry pgtol >= 0 is specified by the user.  The iteration
 *         will stop when
 *
 *                 max{|proj g_i | i = 1, ..., n} <= pgtol
 *
 *         where pg_i is the ith component of the projected gradient.   
 *       On exit pgtol is unchanged.
 *
 *     wa is a double array of length (2mmax + 5)nmax + 12mmax^2 + 12mmax.
 *       wa means "working array". This size must be pre-allocated.
 *
 *     iwa is an integer working array of length 3nmax. Must be pre-allocated
 *
 *     task is a string of characters of length 60 indicating
 *       the current job when entering and quitting this subroutine.
 *
 *     iprint is an integer that must be set by the user.
 *       It controls the frequency and type of output generated:
 *        iprint<0    no output is generated;
 *        iprint=0    print only one line at the last iteration;
 *        0<iprint<99 print also f and |proj g| every iprint iterations;
 *        iprint=99   print details of every iteration except n-vectors;
 *        iprint=100  print also the changes of active set and final x;
 *        iprint>100  print details of every iteration including x and g;
 *       When iprint > 0, the file iterate.dat will be created to
 *                        summarize the iteration.
 *
 *     csave is a string of characters of length 60.
 *
 *     lsave is a boolean working array of dimension 4.
 *       On exit with 'task' = NEW_X, the following information is 
 *                                                             available:
 *         If lsave(1) = true  then  the initial X has been replaced by
 *                                     its projection in the feasible set;
 *         If lsave(2) = true  then  the problem is constrained;
 *         If lsave(3) = true  then  each variable has upper and lower
 *                                     bounds;
 *
 *     isave is an integer array of dimension 44.
 *       On exit with 'task' = NEW_X, the following information is 
 *                                                             available:
 *         isave(22) = the total number of intervals explored in the 
 *                         search of Cauchy points;
 *         isave(26) = the total number of skipped BFGS updates before 
 *                         the current iteration;
 *         isave(30) = the number of current iteration;
 *         isave(31) = the total number of BFGS updates prior the current
 *                         iteration;
 *         isave(33) = the number of intervals explored in the search of
 *                         Cauchy point in the current iteration;
 *         isave(34) = the total number of function and gradient 
 *                         evaluations;
 *         isave(36) = the number of function value or gradient
 *                                  evaluations in the current iteration;
 *         if isave(37) = 0  then the subspace argmin is within the box;
 *         if isave(37) = 1  then the subspace argmin is beyond the box;
 *         isave(38) = the number of free variables in the current
 *                         iteration;
 *         isave(39) = the number of active constraints in the current
 *                         iteration;
 *         n + 1 - isave(40) = the number of variables leaving the set of
 *                           active constraints in the current iteration;
 *         isave(41) = the number of variables entering the set of active
 *                         constraints in the current iteration.
 *
 *     dsave is a double working array of dimension 29.
 *       On exit with 'task' = NEW_X, the following information is
 *                                                             available:
 *         dsave(1) = current 'theta' in the BFGS matrix;
 *         dsave(2) = f(x) in the previous iteration;
 *         dsave(3) = factr*epsmch;
 *         dsave(4) = 2-norm of the line search direction vector;
 *         dsave(5) = the machine precision epsmch generated by the code;
 *         dsave(7) = the accumulated time spent on searching for
 *                                                         Cauchy points;
 *         dsave(8) = the accumulated time spent on
 *                                                 subspace minimization;
 *         dsave(9) = the accumulated time spent on line search;
 *         dsave(11) = the slope of the line search function at
 *                                  the current point of line search;
 *         dsave(12) = the maximum relative step length imposed in
 *                                                           line search;
 *         dsave(13) = the infinity norm of the projected gradient;
 *         dsave(14) = the relative step length in the line search;
 *         dsave(15) = the slope of the line search function at
 *                                 the starting point of the line search;
 *         dsave(16) = the square of the 2-norm of the line search
 *                                                      direction vector.
 */
 

    /* last char may be bool */
    void setulb_(int*, int*, double*, double*, double*, int*, double*, double*, double*, double*, double*, int*, char*, int*, char*, char*, int*, double*, long, long, long);

#ifdef __cplusplus
}
#endif

#endif
